---
alwaysApply: true
description: Authentication and authorization rules using Clerk
---

# Clerk Authentication & Authorization Rules

## Overview
This application uses **Clerk** for all authentication and authorization. All user data must be strictly isolated - users can ONLY access their own data and NEVER access data belonging to other users.

## Critical Security Requirements

### 1. Always Authenticate Users
Every API route and Server Action that accesses user data MUST authenticate the user first:

```typescript
import { auth } from "@clerk/nextjs/server"

export async function GET() {
  const { userId } = await auth()
  if (!userId) {
    return Response.json({ error: "Unauthorized" }, { status: 401 })
  }
  // ... rest of the logic
}
```

### 2. User Data Isolation
**NEVER query the database without filtering by userId.** Every database query that retrieves user-specific data MUST include a userId filter:

```typescript
// ✅ CORRECT - Filtered by userId
const decks = await db
  .select()
  .from(decksTable)
  .where(eq(decksTable.userId, userId))

// ❌ WRONG - No userId filter (exposes all users' data)
const decks = await db.select().from(decksTable)
```

### 3. Resource Ownership Verification
Before updating or deleting any resource, VERIFY that it belongs to the authenticated user:

```typescript
// ✅ CORRECT - Verifies ownership before deletion
const [deck] = await db
  .select()
  .from(decksTable)
  .where(eq(decksTable.id, deckId))
  .limit(1)

if (!deck || deck.userId !== userId) {
  return Response.json({ error: "Forbidden" }, { status: 403 })
}

await db.delete(decksTable).where(eq(decksTable.id, deckId))

// ❌ WRONG - Deletes without ownership check
await db.delete(decksTable).where(eq(decksTable.id, deckId))
```

## Authentication Patterns

### API Routes (Route Handlers)
```typescript
import { auth } from "@clerk/nextjs/server"
import { db } from "@/db"
import { decksTable } from "@/db/schema"
import { eq } from "drizzle-orm"

export async function GET() {
  // 1. Authenticate user
  const { userId } = await auth()
  if (!userId) {
    return Response.json({ error: "Unauthorized" }, { status: 401 })
  }

  // 2. Query with userId filter
  const decks = await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId))

  return Response.json({ decks })
}

export async function DELETE(request: Request) {
  // 1. Authenticate user
  const { userId } = await auth()
  if (!userId) {
    return Response.json({ error: "Unauthorized" }, { status: 401 })
  }

  const { id } = await request.json()

  // 2. Verify ownership
  const [deck] = await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.id, id))
    .limit(1)

  if (!deck || deck.userId !== userId) {
    return Response.json({ error: "Forbidden" }, { status: 403 })
  }

  // 3. Perform deletion
  await db.delete(decksTable).where(eq(decksTable.id, id))

  return Response.json({ success: true })
}
```

### Server Actions
```typescript
"use server"

import { auth } from "@clerk/nextjs/server"
import { db } from "@/db"
import { decksTable } from "@/db/schema"
import { eq } from "drizzle-orm"
import { revalidatePath } from "next/cache"

export async function createDeck(name: string, description?: string) {
  // 1. Authenticate user
  const { userId } = await auth()
  if (!userId) {
    throw new Error("Unauthorized")
  }

  // 2. Create resource with userId
  const [newDeck] = await db
    .insert(decksTable)
    .values({
      userId,
      name,
      description,
    })
    .returning()

  revalidatePath("/decks")
  return newDeck
}

export async function updateDeck(deckId: string, name: string, description?: string) {
  // 1. Authenticate user
  const { userId } = await auth()
  if (!userId) {
    throw new Error("Unauthorized")
  }

  // 2. Verify ownership
  const [deck] = await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.id, deckId))
    .limit(1)

  if (!deck || deck.userId !== userId) {
    throw new Error("Forbidden: You don't have access to this deck")
  }

  // 3. Perform update
  await db
    .update(decksTable)
    .set({ name, description, updatedAt: new Date() })
    .where(eq(decksTable.id, deckId))

  revalidatePath("/decks")
}
```

### Server Components
Server Components can access user data directly:

```typescript
import { auth } from "@clerk/nextjs/server"
import { db } from "@/db"
import { decksTable } from "@/db/schema"
import { eq } from "drizzle-orm"
import { redirect } from "next/navigation"

export default async function DecksPage() {
  // 1. Authenticate user
  const { userId } = await auth()
  if (!userId) {
    redirect("/")
  }

  // 2. Query with userId filter
  const decks = await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId))

  return (
    <div>
      {/* Render decks */}
    </div>
  )
}
```

## Middleware Configuration
The [middleware.ts](mdc:middleware.ts) file protects routes and redirects unauthenticated users to the homepage:

```typescript
import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server"
import { NextResponse } from "next/server"

const isProtectedRoute = createRouteMatcher([
  "/dashboard(.*)",
  "/decks(.*)",
  "/cards(.*)",
  "/study(.*)",
  "/api/decks(.*)",
  "/api/cards(.*)",
])

const isAuthRoute = createRouteMatcher(["/sign-in(.*)", "/sign-up(.*)"]);

export default clerkMiddleware(async (auth, req) => {
  // Redirect auth routes to homepage since we use modals
  if (isAuthRoute(req)) {
    return NextResponse.redirect(new URL("/", req.url));
  }

  // Protect routes and redirect to homepage if not authenticated
  if (isProtectedRoute(req)) {
    await auth.protect({
      unauthenticatedUrl: "/",
      unauthorizedUrl: "/",
    });
  }
})

export const config = {
  matcher: ["/((?!.*\\..*|_next).*)", "/", "/(api|trpc)(.*)"],
}
```

**Note:** This app does not have `/sign-in` or `/sign-up` pages. Authentication happens via modal dialogs on the homepage. The middleware redirects any attempts to access these routes to the homepage.

## Common Security Mistakes to AVOID

### ❌ Missing Authentication Check
```typescript
// WRONG - No auth check
export async function GET() {
  const decks = await db.select().from(decksTable)
  return Response.json({ decks })
}
```

### ❌ Missing User Filter
```typescript
// WRONG - Returns all users' data
const { userId } = await auth()
const decks = await db.select().from(decksTable)
```

### ❌ No Ownership Verification
```typescript
// WRONG - User can delete any deck by ID
const { userId } = await auth()
const { deckId } = await request.json()
await db.delete(decksTable).where(eq(decksTable.id, deckId))
```

### ❌ Using Route Params Without Verification
```typescript
// WRONG - Trusts URL parameter without checking ownership
export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  const { userId } = await auth()
  const deck = await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.id, params.id))
  return Response.json({ deck })
}
```

## Related Files
- Authentication middleware: [middleware.ts](mdc:middleware.ts)
- Database schema: [db/schema.ts](mdc:db/schema.ts)
- Database client: [db/index.ts](mdc:db/index.ts)

## Security Checklist
Before implementing any feature that accesses user data:

- [ ] Authenticate user with `auth()` from Clerk
- [ ] Check if `userId` exists (return 401 if not)
- [ ] Filter all SELECT queries by `userId`
- [ ] Verify ownership before UPDATE/DELETE operations
- [ ] Return 403 Forbidden if user doesn't own the resource
- [ ] Always include `userId` when creating new resources
- [ ] Never expose other users' data in responses
- [ ] Test with multiple users to ensure data isolation

## Error Response Standards
```typescript
// 401 Unauthorized - User is not authenticated
return Response.json({ error: "Unauthorized" }, { status: 401 })

// 403 Forbidden - User is authenticated but doesn't own the resource
return Response.json({ error: "Forbidden" }, { status: 403 })

// For Server Actions
throw new Error("Unauthorized")
throw new Error("Forbidden: You don't have access to this resource")
```
